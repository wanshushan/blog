---
import type { MarkdownHeading } from "astro";
import { siteConfig } from "../../config";

interface Props {
	class?: string;
	headings: MarkdownHeading[];
}

let { headings = [] } = Astro.props;

let minDepth = 10;
for (const heading of headings) {
	minDepth = Math.min(minDepth, heading.depth);
}

const className = Astro.props.class;

const removeTailingHash = (text: string) => {
	let lastIndexOfHash = text.lastIndexOf("#");
	if (lastIndexOfHash !== text.length - 1) {
		return text;
	}

	return text.substring(0, lastIndexOfHash);
};

let heading1Count = 1;

const maxLevel = siteConfig.toc.depth;
---
<table-of-contents class:list={[className, "group", "relative"]} data-max-level={maxLevel}>
    {headings.filter((heading) => heading.depth < minDepth + maxLevel).map((heading) =>
            <a href={`#${heading.slug}`} class="px-2 flex gap-2 relative z-10 w-full min-h-9 rounded-xl
        hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2
    ">
                <div class:list={["w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold",
                    {
                        "bg-[var(--toc-badge-bg)] text-[var(--btn-content)]": heading.depth == minDepth,
                        "ml-4": heading.depth == minDepth + 1,
                        "ml-8": heading.depth == minDepth + 2,
                    }
                ]}
                >
                    {heading.depth == minDepth && heading1Count++}
                    {heading.depth == minDepth + 1 && <div class="w-2 h-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]"></div>}
                    {heading.depth == minDepth + 2 && <div class="w-1.5 h-1.5 rounded-sm bg-black/5 dark:bg-white/10"></div>}
                </div>
                <div class:list={["text-sm", {
                    "text-50": heading.depth == minDepth || heading.depth == minDepth + 1,
                    "text-30": heading.depth == minDepth + 2,
                }]}>{removeTailingHash(heading.text)}</div>
            </a>
    )}
    <div id="active-indicator" style="opacity: 0" class:list={[{'hidden': headings.length == 0}, "z-0 pointer-events-none absolute rounded-xl transition-all duration-200 bg-[var(--btn-plain-bg-hover)]"]}></div>
</table-of-contents>

<script>
class TableOfContents extends HTMLElement {
    tocEl: HTMLElement | null = null;
    visibleClass = "visible";
    observer: IntersectionObserver;
    anchorNavTarget: HTMLElement | null = null;
    headingIdxMap = new Map<string, number>();
    headings: HTMLElement[] = [];
    sections: HTMLElement[] = [];
    tocEntries: HTMLAnchorElement[] = [];
    active: boolean[] = [];
    activeIndicator: HTMLElement | null = null;
    updateScheduled = false;
    swupHookBound = false;
    initStarted = false;

    constructor() {
        super();
        this.observer = new IntersectionObserver(
            this.markVisibleSection, { threshold: 0 }
        );
    };

    get maxLevel() {
        const value = Number(this.dataset.maxLevel ?? "3");
        return Number.isFinite(value) && value > 0 ? value : 3;
    }

    get tocWidget() {
        return document.querySelector<HTMLElement>('widget-layout[data-id="toc-widget"]');
    }

    setWidgetVisibility = (visible: boolean) => {
        this.tocWidget?.classList.toggle("hidden", !visible);
    };

    escapeHtml = (text: string) =>
        text
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#39;");

    removeTrailingHash = (text: string) => {
        const lastIndexOfHash = text.lastIndexOf("#");
        if (lastIndexOfHash !== text.length - 1) return text;
        return text.substring(0, lastIndexOfHash);
    };

    getHeadingDepth = (heading: Element) => {
        const depth = Number(heading.tagName.substring(1));
        return Number.isFinite(depth) ? depth : 6;
    };

    createEntryHTML = (id: string, text: string, depth: number, minDepth: number, headingIndex: number) => {
        const safeText = this.escapeHtml(this.removeTrailingHash(text));
        const href = `#${encodeURIComponent(id)}`;

        const isLevel0 = depth === minDepth;
        const isLevel1 = depth === minDepth + 1;
        const isLevel2 = depth === minDepth + 2;

        const badgeClasses = [
            "w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold",
            isLevel0 ? "bg-[var(--toc-badge-bg)] text-[var(--btn-content)]" : "",
            isLevel1 ? "ml-4" : "",
            isLevel2 ? "ml-8" : "",
        ].filter(Boolean).join(" ");

        const textClasses = [
            "text-sm",
            (isLevel0 || isLevel1) ? "text-50" : "",
            isLevel2 ? "text-30" : "",
        ].filter(Boolean).join(" ");

        let badgeContent = "";
        if (isLevel0) {
            badgeContent = `${headingIndex}`;
        } else if (isLevel1) {
            badgeContent = '<div class="w-2 h-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]"></div>';
        } else if (isLevel2) {
            badgeContent = '<div class="w-1.5 h-1.5 rounded-sm bg-black/5 dark:bg-white/10"></div>';
        }

        return `
<a href="${href}" class="px-2 flex gap-2 relative z-10 w-full min-h-9 rounded-xl hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2">
    <div class="${badgeClasses}">${badgeContent}</div>
    <div class="${textClasses}">${safeText}</div>
</a>`;
    };

    collectPageHeadings = () => {
        const headingElements = Array.from(
            document.querySelectorAll<HTMLElement>(
                "#swup-container .custom-md h1[id], #swup-container .custom-md h2[id], #swup-container .custom-md h3[id], #swup-container .custom-md h4[id], #swup-container .custom-md h5[id], #swup-container .custom-md h6[id]"
            )
        );

        if (!headingElements.length) return [];

        let minDepth = 6;
        headingElements.forEach((heading) => {
            minDepth = Math.min(minDepth, this.getHeadingDepth(heading));
        });
        const maxDepthExclusive = minDepth + this.maxLevel;

        return headingElements
            .filter((heading) => this.getHeadingDepth(heading) < maxDepthExclusive)
            .map((heading) => ({
                id: heading.id,
                text: heading.textContent ?? heading.id,
                depth: this.getHeadingDepth(heading),
                heading,
                section: heading.parentElement,
                minDepth,
            }))
            .filter((item) => item.id && item.section instanceof HTMLElement);
    };

    resetObservers = () => {
        this.sections.forEach((section) => this.observer.unobserve(section));
        this.sections = [];
        this.headings = [];
        this.headingIdxMap.clear();
        this.active = [];
        this.anchorNavTarget = null;
    };

    rebuildFromPageContent = () => {
        if (!this.tocEl) return;

        this.resetObservers();

        const items = this.collectPageHeadings();
        if (!items.length) {
            this.innerHTML = `<div id="active-indicator" style="opacity: 0" class="hidden z-0 pointer-events-none absolute rounded-xl transition-all duration-200 bg-[var(--btn-plain-bg-hover)]"></div>`;
            this.activeIndicator = this.querySelector<HTMLElement>("#active-indicator");
            this.tocEntries = [];
            this.setWidgetVisibility(false);
            return;
        }

        let heading1Count = 1;
        const minDepth = items[0].minDepth;
        const entriesMarkup = items.map((item) => {
            const index = item.depth === minDepth ? heading1Count++ : heading1Count;
            return this.createEntryHTML(item.id, item.text, item.depth, minDepth, index);
        }).join("");

        this.innerHTML = `${entriesMarkup}<div id="active-indicator" style="opacity: 0" class="z-0 pointer-events-none absolute rounded-xl transition-all duration-200 bg-[var(--btn-plain-bg-hover)]"></div>`;

        this.activeIndicator = this.querySelector<HTMLElement>("#active-indicator");
        this.tocEntries = Array.from(this.querySelectorAll<HTMLAnchorElement>('a[href^="#"]'));

        this.sections = new Array(items.length);
        this.headings = new Array(items.length);
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const section = item.section;
            const heading = item.heading;
            if (heading instanceof HTMLElement && section instanceof HTMLElement) {
                this.headings[i] = heading;
                this.sections[i] = section;
                this.headingIdxMap.set(item.id, i);
            }
        }
        this.active = new Array(this.tocEntries.length).fill(false);

        this.sections.forEach((section) => this.observer.observe(section));
        this.setWidgetVisibility(true);
    };

    refreshTOC = () => {
        this.rebuildFromPageContent();
        this.fallback();
        this.update();
    };

    scheduleRefreshAfterLayout = () => {
        requestAnimationFrame(() => {
            this.refreshTOC();
        });
    };

    waitForContentAnimation = (callback: () => void) => {
        const prose = document.querySelector<HTMLElement>("#swup-container .prose");
        if (!prose) {
            callback();
            return;
        }

        const style = window.getComputedStyle(prose);
        const animationName = style.animationName;
        const animationDuration = Number.parseFloat(style.animationDuration);
        const hasAnimation = animationName !== "none" && Number.isFinite(animationDuration) && animationDuration > 0;

        if (!hasAnimation) {
            callback();
            return;
        }

        let called = false;
        const run = () => {
            if (called) return;
            called = true;
            callback();
        };

        prose.addEventListener("animationend", run, { once: true });
        window.setTimeout(run, Math.max(500, animationDuration * 1000 + 120));
    };

    handlePageView = () => {
        this.waitForContentAnimation(() => this.scheduleRefreshAfterLayout());
    };

    bindSwupHook = () => {
        if (this.swupHookBound) return;
        if (window?.swup?.hooks) {
            window.swup.hooks.on("page:view", this.handlePageView);
            this.swupHookBound = true;
            return;
        }

        document.addEventListener("swup:enable", () => this.bindSwupHook(), { once: true });
    };

    markVisibleSection = (entries: IntersectionObserverEntry[]) => {
        entries.forEach((entry) => {
            const id = entry.target.children[0]?.getAttribute("id");
            const idx = id ? this.headingIdxMap.get(id) : undefined;
            if (idx != undefined)
                this.active[idx] = entry.isIntersecting;

            if (entry.isIntersecting && this.anchorNavTarget == entry.target.firstChild)
                this.anchorNavTarget = null;
        });

        if (!this.active.includes(true))
            this.fallback();
        this.update();
    };

    toggleActiveHeading = () => {
        let i = this.active.length - 1;
        let currentIdx = -1;
        while (i >= 0 && !this.active[i]) {
            this.tocEntries[i].classList.remove(this.visibleClass);
            i--;
        }
        while (i >= 0 && this.active[i]) {
            this.tocEntries[i].classList.add(this.visibleClass);
            currentIdx = Math.max(currentIdx, i);
            i--;
        }
        while (i >= 0) {
            this.tocEntries[i].classList.remove(this.visibleClass);
            i--;
        }
        if (currentIdx === -1 || !this.tocEl) {
            this.activeIndicator?.setAttribute("style", `opacity: 0`);
        } else {
            const entry = this.tocEntries[currentIdx];
            const top = entry.offsetTop;
            const height = entry.offsetHeight;
            const left = entry.offsetLeft;
            const width = entry.offsetWidth;

            this.activeIndicator?.setAttribute("style", `opacity: 1; top: ${top}px; height: ${height}px; left: ${left}px; width: ${width}px; border-radius: 0.75rem`);
        }
    };

    getActiveRange = () => {
        let first = -1;
        let last = -1;
        for (let i = 0; i < this.active.length; i++) {
            if (!this.active[i]) continue;
            if (first === -1) first = i;
            last = i;
        }
        return { first, last };
    };

    scrollToActiveHeading = () => {
        // If the TOC widget can accommodate both the topmost
        // and bottommost items, scroll to the topmost item. 
        // Otherwise, scroll to the bottommost one.

        if (this.anchorNavTarget || !this.tocEl) return;
        const { first, last } = this.getActiveRange();
        if (first === -1 || last === -1) return;

        const topmost = this.tocEntries[first];
        const bottommost = this.tocEntries[last];
        const tocHeight = this.tocEl.clientHeight;
        const topmostRect = topmost.getBoundingClientRect();
        const bottommostRect = bottommost.getBoundingClientRect();

        let top;
        if (bottommostRect.bottom - topmostRect.top < 0.9 * tocHeight)
            top = topmost.offsetTop - 32;
        else
            top = bottommost.offsetTop - tocHeight * 0.8;

        this.tocEl.scrollTo({
            top,
            left: 0,
            behavior: "smooth",
        });
    };

    update = () => {
        if (this.updateScheduled) return;
        this.updateScheduled = true;
        requestAnimationFrame(() => {
            this.updateScheduled = false;
            this.toggleActiveHeading();
            this.scrollToActiveHeading();
        });
    };

    fallback = () => {
        if (!this.sections.length) return;
        const viewportHeight = window.innerHeight;

        for (let i = 0; i < this.sections.length; i++) {
            const rect = this.sections[i].getBoundingClientRect();
            let offsetTop = rect.top;
            let offsetBottom = rect.bottom;

            if (this.isInRange(offsetTop, 0, viewportHeight)
                || this.isInRange(offsetBottom, 0, viewportHeight)
                || (offsetTop < 0 && offsetBottom > viewportHeight)) {
                this.markActiveHeading(i);
            }
            else if (offsetTop > viewportHeight) break;
        }
    };

    markActiveHeading = (idx: number)=> {
        this.active[idx] = true;
    };

    handleAnchorClick = (event: Event) => {
        const anchor = event
            .composedPath()
            .find((element) => element instanceof HTMLAnchorElement);

        if (anchor) {
            const id = decodeURIComponent(anchor.hash?.substring(1));
            const idx = this.headingIdxMap.get(id);
            if (idx !== undefined) {
                this.anchorNavTarget = this.headings[idx];
            } else {
                this.anchorNavTarget = null;
            }
        }
    };

    isInRange(value: number, min: number, max: number) {
        return min < value && value < max;
    };

    connectedCallback() {
        this.waitForContentAnimation(() => this.init());
        this.bindSwupHook();
    };

    init() {
        if (this.initStarted) return;
        this.initStarted = true;

        this.tocEl = document.getElementById(
            "toc-inner-wrapper"
        );

        if (!this.tocEl) return;

        this.tocEl.removeEventListener("click", this.handleAnchorClick, {
            capture: true,
        });
        this.tocEl.addEventListener("click", this.handleAnchorClick, {
            capture: true,
        });

        this.scheduleRefreshAfterLayout();
    };

    disconnectedCallback() {
        this.resetObservers();
        this.observer.disconnect();
        this.tocEl?.removeEventListener("click", this.handleAnchorClick);
    };
}

if (!customElements.get("table-of-contents")) {
    customElements.define("table-of-contents", TableOfContents);
}
</script>